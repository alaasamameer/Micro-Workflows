<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="MatlabExpression" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="8.1.devel">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[711, 683]">
    </property>
    <property name="_vergilLocation" class="ptolemy.actor.gui.LocationAttribute" value="[10, 161]">
    </property>
    <property name="SDF Director" class="ptolemy.domains.sdf.kernel.SDFDirector">
        <property name="iterations" class="ptolemy.data.expr.Parameter" value="0">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="85.0, 55.0">
        </property>
<property name="KeplerDocumentation" class="ptolemy.vergil.basic.KeplerDocumentationAttribute">
<property name="description" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="author" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Steve Neuendorffer</configure></property>
<property name="version" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="userLevelDocumentation" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>&#10;&lt;p&gt;The SDF Director is often used to oversee fairly simple, sequential workflows in which the director can determine the order of actor invocation from the workflow. Types of workflows that would run well under an SDF Director include processing and reformatting tabular data, converting one data type to another, and reading and plotting a series of data points. A workflow in which an image is read, processed (rotated, scaled, clipped, filtered, etc.), and then displayed, is also an example of a sequential workflow that requires a director simply to ensure that each actor fires in the proper order (i.e., that each actor executes only after it receives its required inputs).&lt;/p&gt;&#10;&#10;&lt;p&gt;The SDF Director is very efficient and will not tax system resources with overhead. However, this efficiency requires that certain conditions be met, namely that the data consumption and production rate of each actor in an SDF workflow be constant and declared. If an actor reads one piece of data and calculates and outputs a single result, it must always read and output a single token of data. This data rate cannot change during workflow execution and, in general, workflows that require dynamic scheduling and/or flow control cannot use this director. Additionally, the SDF Director has no understanding of passing time (at least by default), and actors that depend on a notion of time may not work as expected. For example, a TimedPlotter actor will plot all values at time zero when used in SDF. &lt;/p&gt;&#10;&#10;&lt;p&gt;By default, the SDF Director requires that all actors in its workflow be connected. Otherwise, the director cannot account for concurrency between disconnected workflow parts. Usually, a PN Director should be used for workflows that contain disconnected actors; however, the SDF Director's allowDisconnectedGraphs parameter may also be set to true. The SDF Director will then schedule each disconnected &quot;island&quot; independently. The director cannot infer the sequential relationship between disconnected actors (i.e., nothing forces the director to finish executing all actors on one island before firing actors on another). However, the order of execution within each island should be correct. Usually, disconnected graphs in an SDF model indicate an error.&lt;/p&gt;&#10; &#10;&lt;p&gt;Because SDF Directors schedule actors to fire only after they receive their inputs, workflows that require loops (feeding an actor's output back into its input port for further processing) can cause &quot;deadlock&quot; errors. The deadlock errors occur because the actor depends on its own output value as an initial input. To fix this problem, use a SampleDelay actor to generate and inject an initial input value into the workflow.&lt;/p&gt;&#10;&#10;&lt;p&gt;The SDF Director determines the order in which actors execute and how many times each actor needs to be fired to complete a single iteration of the workflow. This schedule is calculated BEFORE the director begins to iterate the workflow. Because the SDF Director calculates a schedule in advance, it is quite efficient. However, SDF workflows must be static. In other words, the same number of tokens must be consumed/produced at every iteration of the workflow. Workflows that require dynamic control structures, such as a BooleanSwitch actor that sends output on one of two ports depending on the value of a 'control', cannot be used with an SDF Director because the number of tokens on each output can change for each execution.&lt;/p&gt;&#10;&#10;&lt;p&gt;Unless otherwise specified, the SDF Director assumes that each actor consumes and produces exactly one token per channel on each firing. Actors that do not follow the one-token-per-channel firing convention (e.g., Repeat or Ramp) must declare the number of tokens they produce or consume via the appropriate parameters. &lt;/p&gt;&#10;&#10;&lt;p&gt;The number of times a workflow is iterated is controlled by the director's iterations parameter. By default, this parameter is set to &quot;0&quot;. Note that &quot;0&quot; does not mean &quot;no iterations.&quot; Rather, &quot;0&quot; means that the workflow will iterate forever. Values greater than zero specify the actual number of times the director should execute the entire workflow. A value of 1, meaning that the director will run the workflow once, is often the best setting when building an SDF workflow. &lt;/p&gt;&#10;&#10;&lt;p&gt;The amount of data processed by an SDF workflow is a function of both the number of times the workflow iterates and the value of the director's vectorizationFactor parameter. The vectorizationFactor is used to increase the efficiency of a workflow by increasing the number of times actors fire each time the workflow iterates. If the parameter is set to a positive integer (other than 1), the director will fire each actor the specified number of times more than normal. The default is 1, indicating that no vectorization should be performed. Keep in mind that changing the vectorizationFactor parameter changes the meaning of a nested SDF workflow and may cause deadlock in a workflow that uses it. &lt;/p&gt;&#10;&#10;&lt;p&gt;The SDF Director has several advanced parameters that are generally only relevant when an SDF workflow contains composite components. In most cases the period, timeResolution, synchronizeToRealTime, allowRateChanges, timeResolution, and constrainBufferSizes parameters can be left at their default values.&lt;/p&gt;&#10;&#10;&lt;p&gt;For more information about the SDF Director, see the Ptolemy documentation (http://ptolemy.eecs.berkeley.edu/papers/05/ptIIdesign3-domains/ptIIdesign3-domains.pdf).&lt;/p&gt;&#10;&#10;</configure></property>
<property name="prop:allowDisconnectedGraphs" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Specify whether to allow disconnected actors in the workflow (by default, all actors are required to be connected). If disconnected actors are permitted, the SDF Director will schedule each disconnected 'island' independently. Nothing &quot;forces&quot; the director to finish executing all actors on one island before firing actors on another. However, the order of execution within each island should be correct. Usually, disconnected graphs in an SDF workflow indicate an error.</configure></property>
<property name="prop:allowRateChanges" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Specify whether dynamic rate changes are permitted or not. By default, rate changes are not permitted, and the director will perform a check to disallow such workflows. If the parameter is selected, then workflows that require rate parameters to be modified during execution are valid, and the SDF Director will dynamically compute a new schedule at runtime. This is an advanced parameter that can usually be left at its default value.</configure></property>
<property name="prop:timeResolution" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>The time precision used by this director. All time values are rounded to the nearest multiple of this number. The value is a double that defaults to &quot;1E-10&quot; (which is 10-10). This is an advanced parameter that can usually be left at its default value.</configure></property>
<property name="prop:constrainBufferSizes" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Specify whether buffer sizes are fixed. By default, buffers are fixed, and attempts to write to the buffer that cause the buffer to exceed its scheduled size result in an error. This is an advanced parameter that can usually be left at its default value.</configure></property>
<property name="prop:iterations" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Specify the number of times a workflow is iterated. By default, this parameter is set to &quot;0&quot;. Note that &quot;0&quot; does not mean &quot;no iterations.&quot; Rather, &quot;0&quot; means that the workflow will iterate forever. Values greater than zero specify the actual number of times the director should execute the entire workflow. A value of 1, meaning that the director will run the workflow once, is often the best setting when building an SDF workflow. </configure></property>
<property name="prop:vectorizationFactor" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>The vectorizationFactor is used to increase the efficiency of a workflow by increasing the number of times actors fire each time the workflow iterates. If the parameter is set to a positive integer (other than 1), the director will fire each actor the specified number of times more than normal. The default is 1, indicating that no vectorization should be performed. Keep in mind that changing the vectorizationFactor parameter changes the meaning of a nested SDF workflow and may cause deadlock in a workflow that uses it. </configure></property>
<property name="prop:synchronizeToRealTime" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Specify whether the execution should synchronize to real time or not. By default, the director does not synchronize to real time. If synchronize is selected, the director will only process the workflow when elapsed real time matches the product of the period parameter and the iteration count. Note: if the period parameter has a value of 0.0 (the default), then selecting this parameter has no effect. This is an advanced parameter that can usually be left at its default value.</configure></property>
<property name="prop:period" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>The time period of each iteration. The value is a double that defaults to 0.0, which means that the director does not increment workflow time. If the value greater than 0.0, the actor will increment workflow time each time it fires. This is an advanced parameter that can usually be left at its default value. </configure></property>
</property>    </property>
    <property name="size" class="ptolemy.data.expr.Parameter" value="25">
    </property>
    <property name="frequency" class="ptolemy.data.expr.Parameter" value="pi*0.161">
    </property>
    <property name="annotation" class="ptolemy.kernel.util.Attribute">
        <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
        <property name="_iconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
            <configure>
<svg>
<text style="font-size:14; font-family:SansSerif; fill:darkgray" x="20" y="20">Author: Edward A. Lee</text>
</svg>
</configure>
        </property>
        <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
            <configure>
      <svg>
        <text style="font-size:14; font-family:SansSerif; fill:blue" x="20" y="20">-A-</text>
      </svg>
    </configure>
        </property>
        <property name="_controllerFactory" class="ptolemy.vergil.basic.NodeControllerFactory">
        </property>
        <property name="_editorFactory" class="ptolemy.vergil.toolbox.AnnotationEditorFactory">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[30.0, 290.0]">
        </property>
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={113, 22, 1052, 832}, maximized=false}">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.0">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{355.5, 318.5}">
    </property>
    <property name="Annotation2" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="The MatlabExpression actor on the right invokes a&#10;command in MATLAB. In this case, the function&#10;&quot;surf&quot; (which renders a matrix as a surface plot) is&#10;invoked on the matrix input.&#10;">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[215.0, 35.0]">
        </property>
    </property>
    <property name="derivedFrom" class="org.kepler.moml.NamedObjIdReferralList" value="urn:lsid:kepler-project.org/ns/:765:6:3:urn:lsid:kepler-project.org/ns/:1021:122:2">
    </property>
    <property name="entityId" class="org.kepler.moml.NamedObjId" value="urn:lsid:kepler-project.org/ns/:30286:6:7">
    </property>
    <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textSize" class="ptolemy.data.expr.Parameter" value="12">
        </property>
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{1.0, 0.0, 0.0, 1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="This workflow requires that Matlab be installed on your local machine, and that an environment &#10;variable be set before launching kepler in the specified way:&#10;&#10;32 bit Mac: In a terminal window:&#10; export DYLD_LIBRARY_PATH=/Applications/MATLAB_R2007b/bin/maci &#10; cd $KEPLER&#10; ./kepler.sh&#10;&#10;  For example:&#10;    export DYLD_LIBRARY_PATH=/Applications/MATLAB_R2009a.app/bin/maci/&#10;    cd /Applications/kepler-2.0/Kepler.app/Kepler&#10;    ./kepler.sh&#10;&#10;  On the Mac, an alternative to setting DYLD_LIBRARY_PATH each time is to edit ~/.MacOSX/environment.plist&#10;  by using /Developer/Applications/PropertyListEditor.app.  See &#10;  http://developer.apple.com/mac/library/qa/qa2001/qa1067.html&#10;&#10;64 bit Mac: In a terminal window:&#10;  export DYLD_LIBRARY_PATH=/Applications/MATLAB_R2007b/bin/maci64 &#10; cd $KEPLER&#10; ./kepler.sh&#10;&#10;32 bit Windows:&#10;  Start-&gt;Run cmd&#10; set PATH=%PATH%;c:\Program Files\MATLAB\R2007b\bin\win32 &#10; cd $KEPLER&#10; kepler.bat&#10;&#10;64 bit Windows: &#10; Start-&gt;Run cmd&#10; set PATH=%PATH%;c:\Program Files\MATLAB\R2007b\bin\win64 &#10; cd $KEPLER&#10; kepler.bat&#10;&#10;32 bit Linux: In a terminal window:&#10; export LD_LIBRARY_PATH=/usr/local/matlab/bin/glnx86 &#10; cd $KEPLER&#10; ./kepler.sh&#10;&#10;64 bit Linux: In a terminal window:&#10; export LD_LIBRARY_PATH=/usr/local/matlab/bin/glnxa64 &#10; cd $KEPLER&#10; ./kepler.sh">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[45.0, 325.0]">
        </property>
    </property>
    <entity name="Ramp" class="ptolemy.actor.lib.Ramp">
        <property name="init" class="ptolemy.actor.parameters.PortParameter" value="0.0">
        </property>
        <property name="step" class="ptolemy.actor.parameters.PortParameter" value="frequency">
        </property>
        <doc>Create a sequence of tokens with increasing value</doc>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[80.0, 155.0]">
        </property>
<property name="KeplerDocumentation" class="ptolemy.vergil.basic.KeplerDocumentationAttribute">
<property name="description" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="author" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Yuhong Xiong, Edward A. Lee</configure></property>
<property name="version" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="userLevelDocumentation" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>&#10;&lt;p&gt;The Ramp actor is the equivalent of the &quot;for loop&quot; in many traditional computer languages. Its parameters include an intial value, the amount the value is incremented each time the actor fires (the 'step'), and the upper limit of the value (the firingCountLimit). The actor outputs an integer each time it is fired. &lt;/p&gt;&#10;&#10;&lt;p&gt;The actor's output can be used as a counter (increasing or decreasing), or as a parameter used in an incremented workflow. For example, the output of a Ramp actor can be input to an Expression actor to create file names that are unique for each iteration (e.g., 'file1', 'file2', etc.) The Ramp actor is also particularly useful with PN directed workflows where there is no way to set the number of iterations as a Director parameter. &lt;/p&gt;&#10;&#10;&lt;p&gt;The first time the actor fires, it outputs the value of its init parameter. The increment value, specified with either the step port or parameter, will only be added on the following iteration. To add an increment to the first iteration, use the Accumulator actor.&lt;/p&gt;&#10;&#10;&lt;p&gt;The actor accepts values of any type that support addition.&lt;/p&gt;&#10;</configure></property>
<property name="port:output" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>An output port that broadcasts the incremented value.</configure></property>
<property name="port:trigger" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>An input port that has no declared type (in other words, the port can accept any data type: double, int, array, etc.) If the port is connected, the actor will not fire until the trigger port receives an input token. Connecting the port is optional, but useful when scheduling the actor to perform at a certain time.</configure></property>
<property name="port:step" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>An input port that accepts the amount by which the output is incremented on each iteration. The port accepts a value of any type that supports addition. The value is an integer and defaults to 1.</configure></property>
<property name="prop:firingCountLimit" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>The number of iterations that transpire before the actor indicates that it is finished. If firingCountLimit is set to zero, the actor has no limit imposed.</configure></property>
<property name="prop:step" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>The amount by which the output is incremented on each iteration. The port accepts a value of any type that supports addition. The default is the integer 1.</configure></property>
<property name="prop:init" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>The value produced by the Ramp on its first iteration. The default value is the integer 0.</configure></property>
</property>    </entity>
    <entity name="DoubleToMatrix" class="ptolemy.domains.sdf.lib.DoubleToMatrix">
        <property name="rows" class="ptolemy.data.expr.Parameter" value="size">
        </property>
        <property name="columns" class="ptolemy.data.expr.Parameter" value="1">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[285.0, 155.0]">
        </property>
    </entity>
    <entity name="1:Ramp" class="ptolemy.actor.lib.Ramp">
        <property name="init" class="ptolemy.actor.parameters.PortParameter" value="0.0">
        </property>
        <property name="step" class="ptolemy.actor.parameters.PortParameter" value="frequency*0.5">
        </property>
        <doc>Create a sequence of tokens with increasing value</doc>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[80.0, 230.0]">
        </property>
<property name="KeplerDocumentation" class="ptolemy.vergil.basic.KeplerDocumentationAttribute">
<property name="description" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="author" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Yuhong Xiong, Edward A. Lee</configure></property>
<property name="version" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="userLevelDocumentation" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>&#10;&lt;p&gt;The Ramp actor is the equivalent of the &quot;for loop&quot; in many traditional computer languages. Its parameters include an intial value, the amount the value is incremented each time the actor fires (the 'step'), and the upper limit of the value (the firingCountLimit). The actor outputs an integer each time it is fired. &lt;/p&gt;&#10;&#10;&lt;p&gt;The actor's output can be used as a counter (increasing or decreasing), or as a parameter used in an incremented workflow. For example, the output of a Ramp actor can be input to an Expression actor to create file names that are unique for each iteration (e.g., 'file1', 'file2', etc.) The Ramp actor is also particularly useful with PN directed workflows where there is no way to set the number of iterations as a Director parameter. &lt;/p&gt;&#10;&#10;&lt;p&gt;The first time the actor fires, it outputs the value of its init parameter. The increment value, specified with either the step port or parameter, will only be added on the following iteration. To add an increment to the first iteration, use the Accumulator actor.&lt;/p&gt;&#10;&#10;&lt;p&gt;The actor accepts values of any type that support addition.&lt;/p&gt;&#10;</configure></property>
<property name="port:output" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>An output port that broadcasts the incremented value.</configure></property>
<property name="port:trigger" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>An input port that has no declared type (in other words, the port can accept any data type: double, int, array, etc.) If the port is connected, the actor will not fire until the trigger port receives an input token. Connecting the port is optional, but useful when scheduling the actor to perform at a certain time.</configure></property>
<property name="port:step" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>An input port that accepts the amount by which the output is incremented on each iteration. The port accepts a value of any type that supports addition. The value is an integer and defaults to 1.</configure></property>
<property name="prop:firingCountLimit" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>The number of iterations that transpire before the actor indicates that it is finished. If firingCountLimit is set to zero, the actor has no limit imposed.</configure></property>
<property name="prop:step" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>The amount by which the output is incremented on each iteration. The port accepts a value of any type that supports addition. The default is the integer 1.</configure></property>
<property name="prop:init" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>The value produced by the Ramp on its first iteration. The default value is the integer 0.</configure></property>
</property>    </entity>
    <entity name="2:DoubleToMatrix" class="ptolemy.domains.sdf.lib.DoubleToMatrix">
        <property name="rows" class="ptolemy.data.expr.Parameter" value="1">
        </property>
        <property name="columns" class="ptolemy.data.expr.Parameter" value="size">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[285.0, 230.0]">
        </property>
    </entity>
    <entity name="MultiplyDivide" class="ptolemy.actor.lib.MultiplyDivide">
        <property name="_location" class="ptolemy.kernel.util.Location" value="[405.0, 170.0]">
        </property>
<property name="KeplerDocumentation" class="ptolemy.vergil.basic.KeplerDocumentationAttribute">
<property name="description" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="author" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Edward lee</configure></property>
<property name="version" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="userLevelDocumentation" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>&#10;&lt;p&gt;The MultiplyOrDivide actor reads values via its two input ports (multiply and divide), performs the multiply and/or divide operation, and outputs the result. &lt;/p&gt;&#10;&#10;&lt;p&gt;The actor's input ports are multiports, meaning that they can accept multiple inputs. Any values received via the multiply port will be multiplied; any values received via the divide port will be divided. Either port can be left unconnected. If no input tokens are available on the multiply input, then a numerator of one is assumed for division operations. Alternatively,  the divide port can be left unconnected to create a simple multiplier.&lt;/p&gt;&#10;&#10;&lt;p&gt;Both of the actor's input ports are polymorphic, accepting data of multiple types (integers, floats, etc). The actor will automatically resolve the input type to the least upper bound of the presented values. The actor may permit the multiply and divide inputs to resolve to types that cannot in fact be multiplied or divided. If the actor resolves an input type into a type that cannot be processed, it will generate an error.&lt;/p&gt;&#10;&#10;&lt;p&gt;The actor outputs the result of the calculation and derives an output type from the input values.&lt;/p&gt;&#10;</configure></property>
<property name="port:output" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>An output port that broadcasts the result of the calculation. The actor derives the output type based on the type of the inputs.</configure></property>
<property name="port:multiply" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>A muliport that accepts values to be multiplied. The actor automatically infers the input type based on the type of the input values.</configure></property>
<property name="port:divide" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>A muliport that accepts values to be divided. The actor automatically infers the input type based on the type of the input values.</configure></property>
</property>    </entity>
    <entity name="TrigFunction" class="ptolemy.actor.lib.TrigFunction">
        <property name="function" class="ptolemy.data.expr.StringParameter" value="sin">
            <property name="style" class="ptolemy.actor.gui.style.ChoiceStyle">
                <property name="acos" class="ptolemy.kernel.util.StringAttribute" value="acos">
                </property>
                <property name="asin" class="ptolemy.kernel.util.StringAttribute" value="asin">
                </property>
                <property name="atan" class="ptolemy.kernel.util.StringAttribute" value="atan">
                </property>
                <property name="cos" class="ptolemy.kernel.util.StringAttribute" value="cos">
                </property>
                <property name="sin" class="ptolemy.kernel.util.StringAttribute" value="sin">
                </property>
                <property name="tan" class="ptolemy.kernel.util.StringAttribute" value="tan">
                </property>
            </property>
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.AttributeValueIcon">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="function">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[185.0, 155.0]">
        </property>
<property name="KeplerDocumentation" class="ptolemy.vergil.basic.KeplerDocumentationAttribute">
<property name="description" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="author" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Edward A. Lee</configure></property>
<property name="version" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="userLevelDocumentation" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>&#10;&lt;p&gt;The TrigFunction actor takes an input value and computes a specified trigonometric function. The actor outputs a double token representing the result.&lt;/p&gt;&#10;&#10;&lt;p&gt;The function is specified with the function parameter. Functions include:&lt;/p&gt;&#10;&#10;&lt;ul&gt;&#10;&#10;&lt;li&gt;acos: The arc cosine of an angle, in the range from 0.0 through pi. If the argument is NaN or its absolute value is greater than 1, then the result is NaN. &lt;/li&gt;&#10;&lt;li&gt;asin: The arc sine of an angle, in the range of -pi/2 through pi/2. If the argument is NaN or its absolute value is greater than 1, then the result is NaN. If the argument is positive zero, then the result is positive zero; if the argument is negative zero, then the result is negative zero. &lt;/li&gt;&#10;&lt;li&gt;atan: The arc tangent of an angle, in the range of -pi/2 through pi/2. If the argument is NaN, then the result is NaN. If the argument is positive zero, then the result is positive zero; if the argument is negative zero, then the result is negative zero. &lt;/li&gt;&#10;&lt;li&gt; cos: The trigonometric cosine of an angle. If the argument is NaN or an infinity, then the result is NaN. &lt;/li&gt;&#10;&lt;li&gt;sin: The trigonometric sine of an angle. If the argument is NaN or an infinity, then the result is NaN. &lt;/li&gt;&#10;&lt;li&gt; tan: The trigonometric tangent of an angle. If the argument is NaN or an infinity, then the result is NaN. If the argument is positive zero, then the result is positive zero; if the argument is negative zero, then the result is negative zero &lt;/li&gt;&#10;&lt;/ul&gt;&#10;&#10;&lt;p&gt;NOTE: The above documentation is adapted from the class documentation for java.lang.Math as released in JDK 1.3.&lt;/p&gt;&#10;</configure></property>
<property name="port:output" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>An output port that broadcasts the computed result of the specified trigonometric function.</configure></property>
<property name="port:input" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>An input port that accepts a double token representing a value to evaluate.</configure></property>
<property name="prop:function" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>The function to compute: acos, asin, atan, cos, sin, or tan. The default is sin.</configure></property>
</property>    </entity>
    <entity name="TrigFunction2" class="ptolemy.actor.lib.TrigFunction">
        <property name="function" class="ptolemy.data.expr.StringParameter" value="sin">
            <property name="style" class="ptolemy.actor.gui.style.ChoiceStyle">
                <property name="acos" class="ptolemy.kernel.util.StringAttribute" value="acos">
                </property>
                <property name="asin" class="ptolemy.kernel.util.StringAttribute" value="asin">
                </property>
                <property name="atan" class="ptolemy.kernel.util.StringAttribute" value="atan">
                </property>
                <property name="cos" class="ptolemy.kernel.util.StringAttribute" value="cos">
                </property>
                <property name="sin" class="ptolemy.kernel.util.StringAttribute" value="sin">
                </property>
                <property name="tan" class="ptolemy.kernel.util.StringAttribute" value="tan">
                </property>
            </property>
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.AttributeValueIcon">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="function">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[185.0, 230.0]">
        </property>
<property name="KeplerDocumentation" class="ptolemy.vergil.basic.KeplerDocumentationAttribute">
<property name="description" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="author" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Edward A. Lee</configure></property>
<property name="version" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="userLevelDocumentation" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>&#10;&lt;p&gt;The TrigFunction actor takes an input value and computes a specified trigonometric function. The actor outputs a double token representing the result.&lt;/p&gt;&#10;&#10;&lt;p&gt;The function is specified with the function parameter. Functions include:&lt;/p&gt;&#10;&#10;&lt;ul&gt;&#10;&#10;&lt;li&gt;acos: The arc cosine of an angle, in the range from 0.0 through pi. If the argument is NaN or its absolute value is greater than 1, then the result is NaN. &lt;/li&gt;&#10;&lt;li&gt;asin: The arc sine of an angle, in the range of -pi/2 through pi/2. If the argument is NaN or its absolute value is greater than 1, then the result is NaN. If the argument is positive zero, then the result is positive zero; if the argument is negative zero, then the result is negative zero. &lt;/li&gt;&#10;&lt;li&gt;atan: The arc tangent of an angle, in the range of -pi/2 through pi/2. If the argument is NaN, then the result is NaN. If the argument is positive zero, then the result is positive zero; if the argument is negative zero, then the result is negative zero. &lt;/li&gt;&#10;&lt;li&gt; cos: The trigonometric cosine of an angle. If the argument is NaN or an infinity, then the result is NaN. &lt;/li&gt;&#10;&lt;li&gt;sin: The trigonometric sine of an angle. If the argument is NaN or an infinity, then the result is NaN. &lt;/li&gt;&#10;&lt;li&gt; tan: The trigonometric tangent of an angle. If the argument is NaN or an infinity, then the result is NaN. If the argument is positive zero, then the result is positive zero; if the argument is negative zero, then the result is negative zero &lt;/li&gt;&#10;&lt;/ul&gt;&#10;&#10;&lt;p&gt;NOTE: The above documentation is adapted from the class documentation for java.lang.Math as released in JDK 1.3.&lt;/p&gt;&#10;</configure></property>
<property name="port:output" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>An output port that broadcasts the computed result of the specified trigonometric function.</configure></property>
<property name="port:input" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>An input port that accepts a double token representing a value to evaluate.</configure></property>
<property name="prop:function" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>The function to compute: acos, asin, atan, cos, sin, or tan. The default is sin.</configure></property>
</property>    </entity>
    <entity name="MatlabExpression" class="ptolemy.matlab.Expression">
        <property name="expression" class="ptolemy.data.expr.StringParameter" value="surf(input)">
            <property name="style" class="ptolemy.actor.gui.style.TextStyle">
                <property name="height" class="ptolemy.data.expr.Parameter" value="10">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="30">
                </property>
            </property>
        </property>
        <property name="get1x1asScalars" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="getIntegerMatrices" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="entityId" class="org.kepler.moml.NamedObjId" value="urn:lsid:kepler-project.org:actor:532:1">
        </property>
        <property name="class" class="ptolemy.kernel.util.StringAttribute" value="ptolemy.matlab.Expression">
            <property name="id" class="ptolemy.kernel.util.StringAttribute" value="null">
            </property>
        </property>
        <property name="semanticType11" class="org.kepler.sms.SemanticType" value="urn:lsid:localhost:onto:2:1#GeneralPurpose">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[505.0, 170.0]">
        </property>
<property name="KeplerDocumentation" class="ptolemy.vergil.basic.KeplerDocumentationAttribute">
<property name="description" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="author" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Zoltan Kemenczy and Sean Simmons</configure></property>
<property name="version" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="userLevelDocumentation" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>&#10;&lt;p&gt;&#10;&lt;b&gt;NOTE:&lt;/b&gt; This actor will not run unless Kepler can find the Matlab libraries.&#10;You must set an environment variable to the Matlab libraries directory before running&#10;Kepler. The following examples are for Matlab R2007b installed in a common location;&#10;you should change them to reflect the version and location of Matlab on your computer.&#10;&lt;/p&gt;&#10;&lt;p&gt; &#10;Mac:&#10;&lt;br&gt;In a terminal window:&lt;/br&gt;&#10;&lt;br&gt;export DYLD_LIBRARY_PATH=/Applications/MATLAB_R2007b/bin/maci&lt;/br&gt;&#10;&lt;br&gt;kepler&lt;/br&gt;&#10;&lt;/p&gt;&#10;&lt;p&gt; &#10;Windows: &#10;&lt;br&gt;Start-&gt;Run&lt;/br&gt;&#10;&lt;br&gt;cmd&lt;/br&gt;&#10;&lt;br&gt;set PATH=%PATH%;c:\Program Files\MATLAB\R2007b\bin\win32&lt;/br&gt;&#10;&lt;br&gt;kepler.bat&lt;/br&gt;&#10;&lt;/p&gt;&#10;&lt;p&gt;&#10;Linux:&#10;&lt;br&gt;In a terminal window:&lt;/br&gt;&#10;&lt;br&gt;export LD_LIBRARY_PATH=/usr/local/matlab/bin/glnx86&lt;/br&gt;&#10;&lt;br&gt;kepler&lt;/br&gt;&#10;&lt;/p&gt;     &#10;&lt;p&gt;&#10;On each firing send an expression for evaluation to matlab. The expression &#10;is any valid matlab expression, e.g.:&#10;&#10; &lt;pre&gt;&#10; [out1, out2, ... ] = SomeMatlabFunctionOrExpression( in1, in2, ... );...&#10; &lt;/pre&gt;&#10;&#10; The expression may include references to the input port names, current&#10; time (&lt;i&gt;time&lt;/i&gt;), and a count of the firing (&lt;i&gt;iteration&lt;/i&gt;). This&#10; is similar to the Expression actor. To refer to parameters in scope, use &#10;$$name or $${name} within the expression.&#10; &lt;/p&gt;&#10;&lt;p&gt;&#10; The matlab engine is opened (started) during prefire() by the first&#10; matlab Expression actor. Subsequent open()s simply increment a use&#10; count.&#10;&lt;/p&gt;&#10;&lt;p&gt;&#10; At the start of fire(), &lt;i&gt;clear variables;clear globals&lt;/i&gt; commands are&#10; sent to matlab to clear its workspace. This helps detect errors where the&#10; matlab expression refers to a matlab variable not initialized from the&#10; input ports of this actor instance.&#10;&lt;/p&gt;&#10;&lt;p&gt;&#10; After the evaluation of the matlab expression is complete, the fire()&#10; method iterates through names of output ports and converts matlab&#10; variables with corresponding names to Tokens that are sent to the&#10; corresponding output ports. Incorrect expressions are usually first&#10; detected at this point by not finding the expected variables. If an&#10; output port variable is not found in the matlab engine, an&#10; exception is thrown. The exception description string contains the last&#10; stdout of the matlab engine that usually describes the error.&#10;&lt;/p&gt;&#10;&lt;p&gt;&#10; The parameters &lt;i&gt;get1x1asScalars&lt;/i&gt; and &lt;i&gt;getIntegerMatrices&lt;/i&gt; control&#10; data conversion (see below).&#10;&lt;/p&gt;&#10;&lt;p&gt;&#10; A Parameter named &lt;i&gt;packageDirectories&lt;/i&gt; may be added to this actor&#10; to augment the search path of the matlab engine during the firing of this&#10; actor. The value of this parameter should evaluate to a StringToken,&#10; e.g.:&#10;&#10; &lt;pre&gt;&#10; &quot;path1, path2, ...&quot;&#10; &lt;/pre&gt;&#10;&#10; containing a comma-separated list of paths to be prepended to the matlab&#10; engine search path before &lt;i&gt;expression&lt;/i&gt; is evaluated. The list may&#10; contain paths relative to the directory in which ptolemy was started,&#10; or any directory listed in the current classpath (in that order, first&#10; match wins). See ptolemy.data.expr.UtilityFunctions#findFile(String).&#10; After evaluation, the previous search path is restored.&#10;&lt;/p&gt;&#10;&lt;p&gt;&#10; A Parameter named &lt;i&gt;_debugging&lt;/i&gt; may be used to turn on debug print&#10; statements to stdout from the matlab Engine and the ptmatlab JNI. An IntToken&#10; with a value of 1 turns on Engine debug statements, a value of 2 adds&#10; ptmatlab debug statements as well.  A value of 0 or the absence of the&#10; &lt;i&gt;_debugging&lt;/i&gt; parameter yields normal operation.&#10;      &lt;/p&gt;&#10;      </configure></property>
<property name="port:output" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>&#10;      </configure></property>
<property name="prop:get1x1asScalars" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>&#10;If true, 1x1 matrix results are converted to ScalarTokens instead of a 1x1 &#10;MatrixToken, default is &lt;i&gt;true&lt;/i&gt;.&#10;      </configure></property>
<property name="prop:getIntegerMatrices" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>&#10;If true, all double-valued matrix results are checked to see if all elements &#10;represent integers, and if so, an IntMatrixToken is returned, default is &#10;&lt;i&gt;false&lt;/i&gt; for performance reasons.&#10;      </configure></property>
<property name="prop:expression" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>&#10;The parameter that is evaluated to produce the output. Typically, this parameter &#10;evaluates an expression involving the inputs. To refer to parameters in scope &#10;within the expression, use $name or ${name}, where &quot;name&quot; is the name of the &#10;parameter.&#10;      </configure></property>
</property>
        <port name="input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
    </entity>
    <relation name="relation5" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="1">
        </property>
    </relation>
    <relation name="relation6" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="1">
        </property>
    </relation>
    <relation name="relation7" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="1">
        </property>
    </relation>
    <relation name="relation8" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="1">
        </property>
    </relation>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="1">
        </property>
    </relation>
    <relation name="relation9" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="1">
        </property>
    </relation>
    <relation name="relation2" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="1">
        </property>
    </relation>
    <link port="Ramp.output" relation="relation7"/>
    <link port="DoubleToMatrix.input" relation="relation8"/>
    <link port="DoubleToMatrix.output" relation="relation5"/>
    <link port="1:Ramp.output" relation="relation"/>
    <link port="2:DoubleToMatrix.input" relation="relation9"/>
    <link port="2:DoubleToMatrix.output" relation="relation6"/>
    <link port="MultiplyDivide.multiply" relation="relation5"/>
    <link port="MultiplyDivide.multiply" relation="relation6"/>
    <link port="MultiplyDivide.output" relation="relation2"/>
    <link port="TrigFunction.input" relation="relation7"/>
    <link port="TrigFunction.output" relation="relation8"/>
    <link port="TrigFunction2.input" relation="relation"/>
    <link port="TrigFunction2.output" relation="relation9"/>
    <link port="MatlabExpression.input" relation="relation2"/>
</entity>
