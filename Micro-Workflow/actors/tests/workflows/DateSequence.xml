<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="DateSequence" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="11.0.devel">
    </property>
    <property name="derivedFrom" class="org.kepler.moml.NamedObjIdReferralList">
    </property>
    <property name="entityId" class="org.kepler.moml.NamedObjId" value="urn:lsid:kepler-project.org/ns/:62508:10846:67">
    </property>
    <property name="SDF Director" class="ptolemy.domains.sdf.kernel.SDFDirector">
        <property name="localClock" class="ptolemy.actor.LocalClock">
            <property name="globalTimeResolution" class="ptolemy.actor.parameters.SharedParameter" value="1.0E-10">
            </property>
            <property name="clockRate" class="ptolemy.data.expr.Parameter" value="1.0">
            </property>
        </property>
        <property name="iterations" class="ptolemy.data.expr.Parameter" value="AUTO">
        </property>
        <property name="vectorizationFactor" class="ptolemy.data.expr.Parameter" value="1">
        </property>
        <property name="allowDisconnectedGraphs" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="allowRateChanges" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="constrainBufferSizes" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="period" class="ptolemy.data.expr.Parameter" value="0.0">
        </property>
        <property name="synchronizeToRealTime" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="Scheduler" class="ptolemy.domains.sdf.kernel.SDFScheduler">
            <property name="constrainBufferSizes" class="ptolemy.data.expr.Parameter" value="constrainBufferSizes">
            </property>
        </property>
<property name="KeplerDocumentation" class="ptolemy.vergil.basic.KeplerDocumentationAttribute">
<property name="description" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="author" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Steve Neuendorffer</configure></property>
<property name="version" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="userLevelDocumentation" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>&#10;&lt;p&gt;The SDF Director is often used to oversee fairly simple, sequential workflows in which the director can determine the order of actor invocation from the workflow. Types of workflows that would run well under an SDF Director include processing and reformatting tabular data, converting one data type to another, and reading and plotting a series of data points. A workflow in which an image is read, processed (rotated, scaled, clipped, filtered, etc.), and then displayed, is also an example of a sequential workflow that requires a director simply to ensure that each actor fires in the proper order (i.e., that each actor executes only after it receives its required inputs).&lt;/p&gt;&#10;&#10;&lt;p&gt;The SDF Director is very efficient and will not tax system resources with overhead. However, this efficiency requires that certain conditions be met, namely that the data consumption and production rate of each actor in an SDF workflow be constant and declared. If an actor reads one piece of data and calculates and outputs a single result, it must always read and output a single token of data. This data rate cannot change during workflow execution and, in general, workflows that require dynamic scheduling and/or flow control cannot use this director. Additionally, the SDF Director has no understanding of passing time (at least by default), and actors that depend on a notion of time may not work as expected. For example, a TimedPlotter actor will plot all values at time zero when used in SDF. &lt;/p&gt;&#10;&#10;&lt;p&gt;By default, the SDF Director requires that all actors in its workflow be connected. Otherwise, the director cannot account for concurrency between disconnected workflow parts. Usually, a PN Director should be used for workflows that contain disconnected actors; however, the SDF Director's allowDisconnectedGraphs parameter may also be set to true. The SDF Director will then schedule each disconnected &quot;island&quot; independently. The director cannot infer the sequential relationship between disconnected actors (i.e., nothing forces the director to finish executing all actors on one island before firing actors on another). However, the order of execution within each island should be correct. Usually, disconnected graphs in an SDF model indicate an error.&lt;/p&gt;&#10; &#10;&lt;p&gt;Because SDF Directors schedule actors to fire only after they receive their inputs, workflows that require loops (feeding an actor's output back into its input port for further processing) can cause &quot;deadlock&quot; errors. The deadlock errors occur because the actor depends on its own output value as an initial input. To fix this problem, use a SampleDelay actor to generate and inject an initial input value into the workflow.&lt;/p&gt;&#10;&#10;&lt;p&gt;The SDF Director determines the order in which actors execute and how many times each actor needs to be fired to complete a single iteration of the workflow. This schedule is calculated BEFORE the director begins to iterate the workflow. Because the SDF Director calculates a schedule in advance, it is quite efficient. However, SDF workflows must be static. In other words, the same number of tokens must be consumed/produced at every iteration of the workflow. Workflows that require dynamic control structures, such as a BooleanSwitch actor that sends output on one of two ports depending on the value of a 'control', cannot be used with an SDF Director because the number of tokens on each output can change for each execution.&lt;/p&gt;&#10;&#10;&lt;p&gt;Unless otherwise specified, the SDF Director assumes that each actor consumes and produces exactly one token per channel on each firing. Actors that do not follow the one-token-per-channel firing convention (e.g., Repeat or Ramp) must declare the number of tokens they produce or consume via the appropriate parameters. &lt;/p&gt;&#10;&#10;&lt;p&gt;The number of times a workflow is iterated is controlled by the director's iterations parameter. Since Kepler 2.4, this parameter is set to &quot;AUTO&quot; by default. The director will run the workflow once when it is placed in the top level workflow. When it is placed in a composite actor, the director will keep running the sub-workflow inside of the composite actor until the top level director tells it to stop. In other words, &quot;AUTO&quot; means its value will be &quot;1&quot; when it is placed in the top level workflow, and will be &quot;UNBOUNDED&quot; when it is placed in a composite actor. This default value works for most cases. You can also select &quot;UNBOUNDED&quot; or specify &quot;0&quot; for this parameter, which means the workflow will iterate forever. Concrete numbers can be specified here too for the actual number of times the director should execute the workflow. &lt;/p&gt;&#10;&#10;&lt;p&gt;The amount of data processed by an SDF workflow is a function of both the number of times the workflow iterates and the value of the director's vectorizationFactor parameter. The vectorizationFactor is used to increase the efficiency of a workflow by increasing the number of times actors fire each time the workflow iterates. If the parameter is set to a positive integer (other than 1), the director will fire each actor the specified number of times more than normal. The default is 1, indicating that no vectorization should be performed. Keep in mind that changing the vectorizationFactor parameter changes the meaning of a nested SDF workflow and may cause deadlock in a workflow that uses it. &lt;/p&gt;&#10;&#10;&lt;p&gt;The SDF Director has several advanced parameters that are generally only relevant when an SDF workflow contains composite components. In most cases the period, timeResolution, synchronizeToRealTime, allowRateChanges, timeResolution, and constrainBufferSizes parameters can be left at their default values.&lt;/p&gt;&#10;&#10;&lt;p&gt;For more information about the SDF Director, see the Ptolemy documentation (http://ptolemy.eecs.berkeley.edu/papers/05/ptIIdesign3-domains/ptIIdesign3-domains.pdf).&lt;/p&gt;&#10;&#10;</configure></property>
<property name="prop:allowDisconnectedGraphs" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Specify whether to allow disconnected actors in the workflow (by default, all actors are required to be connected). If disconnected actors are permitted, the SDF Director will schedule each disconnected 'island' independently. Nothing &quot;forces&quot; the director to finish executing all actors on one island before firing actors on another. However, the order of execution within each island should be correct. Usually, disconnected graphs in an SDF workflow indicate an error.</configure></property>
<property name="prop:allowRateChanges" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Specify whether dynamic rate changes are permitted or not. By default, rate changes are not permitted, and the director will perform a check to disallow such workflows. If the parameter is selected, then workflows that require rate parameters to be modified during execution are valid, and the SDF Director will dynamically compute a new schedule at runtime. This is an advanced parameter that can usually be left at its default value.</configure></property>
<property name="prop:constrainBufferSizes" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Specify whether buffer sizes are fixed. By default, buffers are fixed, and attempts to write to the buffer that cause the buffer to exceed its scheduled size result in an error. This is an advanced parameter that can usually be left at its default value.</configure></property>
<property name="prop:timeResolution" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>The time precision used by this director. All time values are rounded to the nearest multiple of this number. The value is a double that defaults to &quot;1E-10&quot; (which is 10-10). This is an advanced parameter that can usually be left at its default value.</configure></property>
<property name="prop:iterations" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Specify the number of times a workflow is iterated. Since Kepler 2.4, this parameter is set to &quot;AUTO&quot; by default. The director will run the workflow once when it is placed in the top level workflow. When it is placed in a composite actor, the director will keep running the sub-workflow inside of the composite actor until the top level director tells it to stop. In other words, &quot;AUTO&quot; means its value will be &quot;1&quot; when it is placed in the top level workflow, and will be &quot;UNBOUNDED&quot; when it is placed in a composite actor. This default value works for most cases. You can also select &quot;UNBOUNDED&quot; or specify &quot;0&quot; for this parameter, which means the workflow will iterate forever. Concrete numbers can be specified here too for the actual number of times the director should execute the workflow. </configure></property>
<property name="prop:vectorizationFactor" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>The vectorizationFactor is used to increase the efficiency of a workflow by increasing the number of times actors fire each time the workflow iterates. If the parameter is set to a positive integer (other than 1), the director will fire each actor the specified number of times more than normal. The default is 1, indicating that no vectorization should be performed. Keep in mind that changing the vectorizationFactor parameter changes the meaning of a nested SDF workflow and may cause deadlock in a workflow that uses it. </configure></property>
<property name="prop:synchronizeToRealTime" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Specify whether the execution should synchronize to real time or not. By default, the director does not synchronize to real time. If synchronize is selected, the director will only process the workflow when elapsed real time matches the product of the period parameter and the iteration count. Note: if the period parameter has a value of 0.0 (the default), then selecting this parameter has no effect. This is an advanced parameter that can usually be left at its default value.</configure></property>
<property name="prop:period" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>The time period of each iteration. The value is a double that defaults to 0.0, which means that the director does not increment workflow time. If the value greater than 0.0, the actor will increment workflow time each time it fires. This is an advanced parameter that can usually be left at its default value. </configure></property>
</property>        <property name="entityId" class="org.kepler.moml.NamedObjId" value="urn:lsid:kepler-project.org:director:1:2">
        </property>
        <property name="class" class="ptolemy.kernel.util.StringAttribute" value="ptolemy.domains.sdf.kernel.SDFDirector">
            <property name="id" class="ptolemy.kernel.util.StringAttribute" value="urn:lsid:kepler-project.org:directorclass:1:2">
            </property>
        </property>
        <property name="semanticType00" class="org.kepler.sms.SemanticType" value="urn:lsid:localhost:onto:1:1#Director">
        </property>
        <property name="semanticType11" class="org.kepler.sms.SemanticType" value="urn:lsid:localhost:onto:2:1#Director">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{120, 110}">
        </property>
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={332, 34, 1128, 980}, maximized=false}">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[818, 822]">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.0">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{399.0, 401.0}">
    </property>
    <entity name="CreateDate" class="org.kepler.date.CreateDate">
        <property name="format" class="ptolemy.actor.parameters.PortParameter" value="yyyyMMdd">
        </property>
        <property name="input" class="ptolemy.actor.parameters.PortParameter" value="20000101">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[160.0, 188.0]">
        </property>
    </entity>
    <entity name="CreateDate2" class="org.kepler.date.CreateDate">
        <property name="format" class="ptolemy.actor.parameters.PortParameter" value="yyyyMMdd">
        </property>
        <property name="input" class="ptolemy.actor.parameters.PortParameter" value="20010101">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[160.0, 258.0]">
        </property>
    </entity>
    <entity name="String Constant" class="ptolemy.actor.lib.StringConst">
        <property name="value" class="ptolemy.data.expr.Parameter" value="20000101">
        </property>
        <property name="firingCountLimit" class="ptolemy.data.expr.Parameter" value="NONE">
        </property>
        <property name="NONE" class="ptolemy.data.expr.Parameter" value="0">
        </property>
<property name="KeplerDocumentation" class="ptolemy.vergil.basic.KeplerDocumentationAttribute">
<property name="description" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="author" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Edward Lee</configure></property>
<property name="version" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="userLevelDocumentation" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>&lt;p&gt;The StringConstant actor outputs a string specified via the actor's value parameter.&lt;/p&gt;&#10;&#10;&lt;p&gt;Specifying strings with the StringConstant actor is convenient, as the actor does not require that strings be surrounded by quotes. The actor is often used to specify file paths, which can be selected using the Browse button available in the actor's parameters.&lt;/p&gt;&#10;&#10;&lt;p&gt;Specified string values can include references to parameters within scope (i.e., parameters defined at the same level of the hierarchy or higher). &lt;/p&gt;&#10;&#10;&lt;p&gt;NOTE: If using a PN Director, the 'firingCountLimit' parameter is often set to a finite integer (e.g. '1') so that the workflow will terminate. &lt;/p&gt;&#10;&#10;</configure></property>
<property name="port:output" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>An output port that broadcasts a string constant specified by the value parameter.  </configure></property>
<property name="port:trigger" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>A multiport that has no declared type (in other words, the port can accept any data type: double, int, array, etc.) If the port is connected, the actor will not fire until the trigger port receives an input token. Connecting the port is optional, but useful when scheduling the actor to perform at a certain time. </configure></property>
<property name="prop:firingCountLimit" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>The limit on the number of times the actor will fire. The default value is 'NONE', meaning there is no limit on the number of time the constant will be provided to the output port. Any integer can be provided as a value for this parameter.</configure></property>
<property name="prop:value" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>The value produced by the actor. Specified strings do not require enclosing quotes. (To include a '$' sign in the string, enter '$$'.)</configure></property>
</property>        <property name="entityId" class="org.kepler.moml.NamedObjId" value="urn:lsid:kepler-project.org/ns/:62508:10852:1">
        </property>
        <property name="class" class="ptolemy.kernel.util.StringAttribute" value="ptolemy.actor.lib.StringConst">
            <property name="id" class="ptolemy.kernel.util.StringAttribute" value="urn:lsid:kepler-project.org:class:1052:1">
            </property>
        </property>
        <property name="semanticType00" class="org.kepler.sms.SemanticType" value="urn:lsid:localhost:onto:1:1#StringFunctionActor">
        </property>
        <property name="semanticType11" class="org.kepler.sms.SemanticType" value="urn:lsid:localhost:onto:2:1#Constant">
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.BoxedValueIcon">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="value">
            </property>
            <property name="displayWidth" class="ptolemy.data.expr.Parameter" value="60">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[60.0, 220.0]">
        </property>
        <property name="derivedFrom" class="org.kepler.moml.NamedObjIdReferralList" value="urn:lsid:kepler-project.org:actor:204:1:urn:lsid:kepler-project.org/ns/:52156:132:1">
        </property>
    </entity>
    <entity name="String Constant2" class="ptolemy.actor.lib.StringConst">
        <property name="value" class="ptolemy.data.expr.Parameter" value="20010101">
        </property>
        <property name="firingCountLimit" class="ptolemy.data.expr.Parameter" value="NONE">
        </property>
        <property name="NONE" class="ptolemy.data.expr.Parameter" value="0">
        </property>
<property name="KeplerDocumentation" class="ptolemy.vergil.basic.KeplerDocumentationAttribute">
<property name="description" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="author" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Edward Lee</configure></property>
<property name="version" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="userLevelDocumentation" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>&lt;p&gt;The StringConstant actor outputs a string specified via the actor's value parameter.&lt;/p&gt;&#10;&#10;&lt;p&gt;Specifying strings with the StringConstant actor is convenient, as the actor does not require that strings be surrounded by quotes. The actor is often used to specify file paths, which can be selected using the Browse button available in the actor's parameters.&lt;/p&gt;&#10;&#10;&lt;p&gt;Specified string values can include references to parameters within scope (i.e., parameters defined at the same level of the hierarchy or higher). &lt;/p&gt;&#10;&#10;&lt;p&gt;NOTE: If using a PN Director, the 'firingCountLimit' parameter is often set to a finite integer (e.g. '1') so that the workflow will terminate. &lt;/p&gt;&#10;&#10;</configure></property>
<property name="port:output" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>An output port that broadcasts a string constant specified by the value parameter.  </configure></property>
<property name="port:trigger" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>A multiport that has no declared type (in other words, the port can accept any data type: double, int, array, etc.) If the port is connected, the actor will not fire until the trigger port receives an input token. Connecting the port is optional, but useful when scheduling the actor to perform at a certain time. </configure></property>
<property name="prop:firingCountLimit" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>The limit on the number of times the actor will fire. The default value is 'NONE', meaning there is no limit on the number of time the constant will be provided to the output port. Any integer can be provided as a value for this parameter.</configure></property>
<property name="prop:value" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>The value produced by the actor. Specified strings do not require enclosing quotes. (To include a '$' sign in the string, enter '$$'.)</configure></property>
</property>        <property name="entityId" class="org.kepler.moml.NamedObjId" value="urn:lsid:kepler-project.org/ns/:62508:10853:1">
        </property>
        <property name="class" class="ptolemy.kernel.util.StringAttribute" value="ptolemy.actor.lib.StringConst">
            <property name="id" class="ptolemy.kernel.util.StringAttribute" value="urn:lsid:kepler-project.org:class:1052:1">
            </property>
        </property>
        <property name="semanticType00" class="org.kepler.sms.SemanticType" value="urn:lsid:localhost:onto:1:1#StringFunctionActor">
        </property>
        <property name="semanticType11" class="org.kepler.sms.SemanticType" value="urn:lsid:localhost:onto:2:1#Constant">
        </property>
        <property name="_icon" class="ptolemy.vergil.icon.BoxedValueIcon">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="value">
            </property>
            <property name="displayWidth" class="ptolemy.data.expr.Parameter" value="60">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[60.0, 290.0]">
        </property>
        <property name="derivedFrom" class="org.kepler.moml.NamedObjIdReferralList" value="urn:lsid:kepler-project.org:actor:204:1:urn:lsid:kepler-project.org/ns/:52156:124:2">
        </property>
    </entity>
    <entity name="DateSequence" class="org.kepler.date.DateSequence">
        <property name="step" class="ptolemy.actor.parameters.PortParameter" value="1">
        </property>
        <property name="stepUnits" class="ptolemy.data.expr.StringParameter" value="Month">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[315.0, 225.0]">
        </property>
    </entity>
    <entity name="DateSequence2" class="org.kepler.date.DateSequence">
        <property name="step" class="ptolemy.actor.parameters.PortParameter" value="1">
        </property>
        <property name="stepUnits" class="ptolemy.data.expr.StringParameter" value="Day">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[310.0, 320.0]">
        </property>
    </entity>
    <entity name="Test" class="ptolemy.actor.lib.Test">
        <property name="correctValues" class="ptolemy.data.expr.Parameter" value="{{{date(&quot;Sat Jan 01 00:00:00.000000000 -0800 2000&quot;), date(&quot;Tue Feb 01 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Mar 01 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sat Apr 01 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon May 01 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Jun 01 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Jul 01 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Aug 01 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Sep 01 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Oct 01 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Nov 01 00:00:00.000000000 -0800 2000&quot;), date(&quot;Fri Dec 01 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Jan 01 00:00:00.000000000 -0800 2001&quot;)}}}">
        </property>
        <property name="tolerance" class="ptolemy.data.expr.Parameter" value="1.0E-9">
        </property>
        <property name="requireAllCorrectValues" class="ptolemy.actor.parameters.SharedParameter" value="true">
        </property>
        <property name="trainingMode" class="ptolemy.actor.parameters.SharedParameter" value="false">
        </property>
<property name="KeplerDocumentation" class="ptolemy.vergil.basic.KeplerDocumentationAttribute">
<property name="description" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="author" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Edward A. Lee, Christopher Hylands, Jim Armstrong</configure></property>
<property name="version" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="userLevelDocumentation" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>&lt;p&gt;The Test actor reads an input value of any type and compares it to a corresponding value in a specified array of values. If the two values match, the actor fires successfully. If the two values do not match, the actor generates an error. The actor outputs a Boolean token: false if the actor's iteration count is less than or equal to the length of the comparison array; true if the iteration count is greater than the length of the array. The Boolean output can be fed to a Stop actor to stop the workflow upon successfully matching test data.&lt;/p&gt;&#10;&#10;&lt;p&gt;Unlike the NonstrictTest actor, the Test actor supports a multiport input. The actor also differs from NonstrictTest in that it requires that all inputs be present. &lt;/p&gt;&#10;&#10;&lt;p&gt;The comparison value is specified with the correctValues parameter. The parameter accepts an array of values, the type of which must match the type of the input (the default array is {true}). The actor cycles through the array values, comparing each consecutive input to the next token in the correctValues array. After each of the values in the correctValues parameter has been matched, any subsequent iteration always succeeds. This behavior allows the actor to be used as a &quot;power-up&quot; test for a model; the actor will check the first few iterations against some known results. &lt;/p&gt;&#10;&#10;&lt;p&gt;The input is a multiport. If more than one input channel exists, then each element of correctValues must itself be an array, with length matching the number of channels. &lt;/p&gt;&#10;&#10;&lt;p&gt;Suppose for example that the input consists of one channel, and the first three inputs should be 1, 2, and 3. Then set correctValues to &#10;&#10; {1, 2, 3}&lt;/p&gt;&#10;&#10;&lt;p&gt;Suppose instead that the input consists of two channels, and the correct values in the first iteration are 1 on the first channel and 2 on the second. Then on the second iteration, the correct values are 3 on the first channel and 4 on the second. Then set correctValues to &#10;&#10; {{1, 2}, {3, 4}}&#10;&#10;Note: With this setting, no tests are performed after the first two iterations of this actor. &lt;/p&gt;&#10;&#10;&lt;p&gt;The input values are checked when the actor fires. If an input value is missing or differs from what it should be, then the actor generates an error. To check the input value after the actor fires, then use the NonstrictTest actor. &lt;/p&gt;&#10;&#10;&lt;p&gt;If the input is a double or complex token, then the comparison &quot;passes&quot; if the value is close to what it should be (i.e., within the specified tolerance). Tolerance is specified with the tolerance parameter, and defaults to 10-9.&lt;/p&gt;</configure></property>
<property name="port:input" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>A multiport that accepts tokens of any type.</configure></property>
<property name="port:output" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Boolean output that is false as long as there is data to compare against the input; the value becomes true on the first firing after such data has been exhausted.</configure></property>
<property name="prop:correctValues" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>An array specifying what the input should be. If more than one input channel exists, then each element of the array must itself be an array, with length matching the number of channels. The default is a one-by-one array containing a Boolean true.</configure></property>
<property name="prop:tolerance" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>A double token specifying how closely the input must match the value from the correctValues array. The default is 10-9.</configure></property>
<property name="prop:trainingMode" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Select the trainingMode parameter to collect the input values and place them in the correctValues array. The trainingMode parameter is a shared parameter, meaning that changing it for any one instance of the actor in the model will change all instances.</configure></property>
</property>        <property name="entityId" class="org.kepler.moml.NamedObjId" value="urn:lsid:kepler-project.org:actor:116:1">
        </property>
        <property name="class" class="ptolemy.kernel.util.StringAttribute" value="ptolemy.actor.lib.Test">
            <property name="id" class="ptolemy.kernel.util.StringAttribute" value="urn:lsid:kepler-project.org:class:985:1">
            </property>
        </property>
        <property name="semanticType00" class="org.kepler.sms.SemanticType" value="urn:lsid:localhost:onto:1:1#UnitTestControlActor">
        </property>
        <property name="semanticType11" class="org.kepler.sms.SemanticType" value="urn:lsid:localhost:onto:2:1#UnitTestControl">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[475.0, 225.0]">
        </property>
    </entity>
    <entity name="Test2" class="ptolemy.actor.lib.Test">
        <property name="correctValues" class="ptolemy.data.expr.Parameter" value="{{{date(&quot;Sat Jan 01 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sun Jan 02 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Jan 03 00:00:00.000000000 -0800 2000&quot;), date(&quot;Tue Jan 04 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Jan 05 00:00:00.000000000 -0800 2000&quot;), date(&quot;Thu Jan 06 00:00:00.000000000 -0800 2000&quot;), date(&quot;Fri Jan 07 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sat Jan 08 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sun Jan 09 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Jan 10 00:00:00.000000000 -0800 2000&quot;), date(&quot;Tue Jan 11 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Jan 12 00:00:00.000000000 -0800 2000&quot;), date(&quot;Thu Jan 13 00:00:00.000000000 -0800 2000&quot;), date(&quot;Fri Jan 14 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sat Jan 15 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sun Jan 16 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Jan 17 00:00:00.000000000 -0800 2000&quot;), date(&quot;Tue Jan 18 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Jan 19 00:00:00.000000000 -0800 2000&quot;), date(&quot;Thu Jan 20 00:00:00.000000000 -0800 2000&quot;), date(&quot;Fri Jan 21 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sat Jan 22 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sun Jan 23 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Jan 24 00:00:00.000000000 -0800 2000&quot;), date(&quot;Tue Jan 25 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Jan 26 00:00:00.000000000 -0800 2000&quot;), date(&quot;Thu Jan 27 00:00:00.000000000 -0800 2000&quot;), date(&quot;Fri Jan 28 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sat Jan 29 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sun Jan 30 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Jan 31 00:00:00.000000000 -0800 2000&quot;), date(&quot;Tue Feb 01 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Feb 02 00:00:00.000000000 -0800 2000&quot;), date(&quot;Thu Feb 03 00:00:00.000000000 -0800 2000&quot;), date(&quot;Fri Feb 04 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sat Feb 05 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sun Feb 06 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Feb 07 00:00:00.000000000 -0800 2000&quot;), date(&quot;Tue Feb 08 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Feb 09 00:00:00.000000000 -0800 2000&quot;), date(&quot;Thu Feb 10 00:00:00.000000000 -0800 2000&quot;), date(&quot;Fri Feb 11 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sat Feb 12 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sun Feb 13 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Feb 14 00:00:00.000000000 -0800 2000&quot;), date(&quot;Tue Feb 15 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Feb 16 00:00:00.000000000 -0800 2000&quot;), date(&quot;Thu Feb 17 00:00:00.000000000 -0800 2000&quot;), date(&quot;Fri Feb 18 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sat Feb 19 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sun Feb 20 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Feb 21 00:00:00.000000000 -0800 2000&quot;), date(&quot;Tue Feb 22 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Feb 23 00:00:00.000000000 -0800 2000&quot;), date(&quot;Thu Feb 24 00:00:00.000000000 -0800 2000&quot;), date(&quot;Fri Feb 25 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sat Feb 26 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sun Feb 27 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Feb 28 00:00:00.000000000 -0800 2000&quot;), date(&quot;Tue Feb 29 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Mar 01 00:00:00.000000000 -0800 2000&quot;), date(&quot;Thu Mar 02 00:00:00.000000000 -0800 2000&quot;), date(&quot;Fri Mar 03 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sat Mar 04 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sun Mar 05 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Mar 06 00:00:00.000000000 -0800 2000&quot;), date(&quot;Tue Mar 07 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Mar 08 00:00:00.000000000 -0800 2000&quot;), date(&quot;Thu Mar 09 00:00:00.000000000 -0800 2000&quot;), date(&quot;Fri Mar 10 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sat Mar 11 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sun Mar 12 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Mar 13 00:00:00.000000000 -0800 2000&quot;), date(&quot;Tue Mar 14 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Mar 15 00:00:00.000000000 -0800 2000&quot;), date(&quot;Thu Mar 16 00:00:00.000000000 -0800 2000&quot;), date(&quot;Fri Mar 17 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sat Mar 18 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sun Mar 19 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Mar 20 00:00:00.000000000 -0800 2000&quot;), date(&quot;Tue Mar 21 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Mar 22 00:00:00.000000000 -0800 2000&quot;), date(&quot;Thu Mar 23 00:00:00.000000000 -0800 2000&quot;), date(&quot;Fri Mar 24 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sat Mar 25 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sun Mar 26 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Mar 27 00:00:00.000000000 -0800 2000&quot;), date(&quot;Tue Mar 28 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Mar 29 00:00:00.000000000 -0800 2000&quot;), date(&quot;Thu Mar 30 00:00:00.000000000 -0800 2000&quot;), date(&quot;Fri Mar 31 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sat Apr 01 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sun Apr 02 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Apr 03 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Apr 04 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Apr 05 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Apr 06 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Apr 07 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Apr 08 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Apr 09 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Apr 10 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Apr 11 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Apr 12 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Apr 13 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Apr 14 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Apr 15 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Apr 16 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Apr 17 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Apr 18 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Apr 19 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Apr 20 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Apr 21 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Apr 22 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Apr 23 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Apr 24 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Apr 25 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Apr 26 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Apr 27 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Apr 28 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Apr 29 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Apr 30 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon May 01 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue May 02 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed May 03 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu May 04 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri May 05 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat May 06 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun May 07 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon May 08 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue May 09 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed May 10 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu May 11 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri May 12 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat May 13 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun May 14 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon May 15 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue May 16 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed May 17 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu May 18 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri May 19 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat May 20 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun May 21 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon May 22 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue May 23 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed May 24 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu May 25 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri May 26 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat May 27 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun May 28 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon May 29 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue May 30 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed May 31 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Jun 01 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Jun 02 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Jun 03 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Jun 04 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Jun 05 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Jun 06 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Jun 07 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Jun 08 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Jun 09 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Jun 10 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Jun 11 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Jun 12 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Jun 13 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Jun 14 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Jun 15 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Jun 16 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Jun 17 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Jun 18 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Jun 19 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Jun 20 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Jun 21 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Jun 22 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Jun 23 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Jun 24 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Jun 25 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Jun 26 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Jun 27 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Jun 28 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Jun 29 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Jun 30 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Jul 01 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Jul 02 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Jul 03 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Jul 04 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Jul 05 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Jul 06 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Jul 07 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Jul 08 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Jul 09 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Jul 10 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Jul 11 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Jul 12 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Jul 13 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Jul 14 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Jul 15 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Jul 16 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Jul 17 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Jul 18 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Jul 19 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Jul 20 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Jul 21 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Jul 22 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Jul 23 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Jul 24 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Jul 25 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Jul 26 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Jul 27 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Jul 28 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Jul 29 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Jul 30 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Jul 31 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Aug 01 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Aug 02 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Aug 03 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Aug 04 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Aug 05 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Aug 06 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Aug 07 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Aug 08 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Aug 09 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Aug 10 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Aug 11 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Aug 12 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Aug 13 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Aug 14 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Aug 15 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Aug 16 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Aug 17 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Aug 18 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Aug 19 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Aug 20 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Aug 21 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Aug 22 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Aug 23 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Aug 24 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Aug 25 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Aug 26 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Aug 27 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Aug 28 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Aug 29 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Aug 30 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Aug 31 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Sep 01 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Sep 02 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Sep 03 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Sep 04 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Sep 05 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Sep 06 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Sep 07 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Sep 08 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Sep 09 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Sep 10 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Sep 11 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Sep 12 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Sep 13 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Sep 14 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Sep 15 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Sep 16 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Sep 17 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Sep 18 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Sep 19 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Sep 20 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Sep 21 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Sep 22 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Sep 23 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Sep 24 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Sep 25 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Sep 26 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Sep 27 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Sep 28 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Sep 29 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Sep 30 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Oct 01 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Oct 02 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Oct 03 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Oct 04 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Oct 05 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Oct 06 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Oct 07 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Oct 08 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Oct 09 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Oct 10 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Oct 11 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Oct 12 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Oct 13 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Oct 14 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Oct 15 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Oct 16 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Oct 17 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Oct 18 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Oct 19 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Oct 20 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Oct 21 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Oct 22 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Oct 23 00:00:00.000000000 -0700 2000&quot;), date(&quot;Tue Oct 24 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Oct 25 00:00:00.000000000 -0700 2000&quot;), date(&quot;Thu Oct 26 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Oct 27 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Oct 28 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sun Oct 29 00:00:00.000000000 -0700 2000&quot;), date(&quot;Mon Oct 30 00:00:00.000000000 -0800 2000&quot;), date(&quot;Tue Oct 31 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Nov 01 00:00:00.000000000 -0800 2000&quot;), date(&quot;Thu Nov 02 00:00:00.000000000 -0800 2000&quot;), date(&quot;Fri Nov 03 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sat Nov 04 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sun Nov 05 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Nov 06 00:00:00.000000000 -0800 2000&quot;), date(&quot;Tue Nov 07 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Nov 08 00:00:00.000000000 -0800 2000&quot;), date(&quot;Thu Nov 09 00:00:00.000000000 -0800 2000&quot;), date(&quot;Fri Nov 10 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sat Nov 11 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sun Nov 12 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Nov 13 00:00:00.000000000 -0800 2000&quot;), date(&quot;Tue Nov 14 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Nov 15 00:00:00.000000000 -0800 2000&quot;), date(&quot;Thu Nov 16 00:00:00.000000000 -0800 2000&quot;), date(&quot;Fri Nov 17 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sat Nov 18 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sun Nov 19 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Nov 20 00:00:00.000000000 -0800 2000&quot;), date(&quot;Tue Nov 21 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Nov 22 00:00:00.000000000 -0800 2000&quot;), date(&quot;Thu Nov 23 00:00:00.000000000 -0800 2000&quot;), date(&quot;Fri Nov 24 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sat Nov 25 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sun Nov 26 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Nov 27 00:00:00.000000000 -0800 2000&quot;), date(&quot;Tue Nov 28 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Nov 29 00:00:00.000000000 -0800 2000&quot;), date(&quot;Thu Nov 30 00:00:00.000000000 -0800 2000&quot;), date(&quot;Fri Dec 01 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sat Dec 02 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sun Dec 03 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Dec 04 00:00:00.000000000 -0800 2000&quot;), date(&quot;Tue Dec 05 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Dec 06 00:00:00.000000000 -0800 2000&quot;), date(&quot;Thu Dec 07 00:00:00.000000000 -0800 2000&quot;), date(&quot;Fri Dec 08 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sat Dec 09 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sun Dec 10 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Dec 11 00:00:00.000000000 -0800 2000&quot;), date(&quot;Tue Dec 12 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Dec 13 00:00:00.000000000 -0800 2000&quot;), date(&quot;Thu Dec 14 00:00:00.000000000 -0800 2000&quot;), date(&quot;Fri Dec 15 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sat Dec 16 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sun Dec 17 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Dec 18 00:00:00.000000000 -0800 2000&quot;), date(&quot;Tue Dec 19 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Dec 20 00:00:00.000000000 -0800 2000&quot;), date(&quot;Thu Dec 21 00:00:00.000000000 -0800 2000&quot;), date(&quot;Fri Dec 22 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sat Dec 23 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sun Dec 24 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Dec 25 00:00:00.000000000 -0800 2000&quot;), date(&quot;Tue Dec 26 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Dec 27 00:00:00.000000000 -0800 2000&quot;), date(&quot;Thu Dec 28 00:00:00.000000000 -0800 2000&quot;), date(&quot;Fri Dec 29 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sat Dec 30 00:00:00.000000000 -0800 2000&quot;), date(&quot;Sun Dec 31 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Jan 01 00:00:00.000000000 -0800 2001&quot;)}}}">
        </property>
        <property name="tolerance" class="ptolemy.data.expr.Parameter" value="1.0E-9">
        </property>
        <property name="requireAllCorrectValues" class="ptolemy.actor.parameters.SharedParameter" value="true">
        </property>
        <property name="trainingMode" class="ptolemy.actor.parameters.SharedParameter" value="false">
        </property>
<property name="KeplerDocumentation" class="ptolemy.vergil.basic.KeplerDocumentationAttribute">
<property name="description" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="author" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Edward A. Lee, Christopher Hylands, Jim Armstrong</configure></property>
<property name="version" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="userLevelDocumentation" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>&lt;p&gt;The Test actor reads an input value of any type and compares it to a corresponding value in a specified array of values. If the two values match, the actor fires successfully. If the two values do not match, the actor generates an error. The actor outputs a Boolean token: false if the actor's iteration count is less than or equal to the length of the comparison array; true if the iteration count is greater than the length of the array. The Boolean output can be fed to a Stop actor to stop the workflow upon successfully matching test data.&lt;/p&gt;&#10;&#10;&lt;p&gt;Unlike the NonstrictTest actor, the Test actor supports a multiport input. The actor also differs from NonstrictTest in that it requires that all inputs be present. &lt;/p&gt;&#10;&#10;&lt;p&gt;The comparison value is specified with the correctValues parameter. The parameter accepts an array of values, the type of which must match the type of the input (the default array is {true}). The actor cycles through the array values, comparing each consecutive input to the next token in the correctValues array. After each of the values in the correctValues parameter has been matched, any subsequent iteration always succeeds. This behavior allows the actor to be used as a &quot;power-up&quot; test for a model; the actor will check the first few iterations against some known results. &lt;/p&gt;&#10;&#10;&lt;p&gt;The input is a multiport. If more than one input channel exists, then each element of correctValues must itself be an array, with length matching the number of channels. &lt;/p&gt;&#10;&#10;&lt;p&gt;Suppose for example that the input consists of one channel, and the first three inputs should be 1, 2, and 3. Then set correctValues to &#10;&#10; {1, 2, 3}&lt;/p&gt;&#10;&#10;&lt;p&gt;Suppose instead that the input consists of two channels, and the correct values in the first iteration are 1 on the first channel and 2 on the second. Then on the second iteration, the correct values are 3 on the first channel and 4 on the second. Then set correctValues to &#10;&#10; {{1, 2}, {3, 4}}&#10;&#10;Note: With this setting, no tests are performed after the first two iterations of this actor. &lt;/p&gt;&#10;&#10;&lt;p&gt;The input values are checked when the actor fires. If an input value is missing or differs from what it should be, then the actor generates an error. To check the input value after the actor fires, then use the NonstrictTest actor. &lt;/p&gt;&#10;&#10;&lt;p&gt;If the input is a double or complex token, then the comparison &quot;passes&quot; if the value is close to what it should be (i.e., within the specified tolerance). Tolerance is specified with the tolerance parameter, and defaults to 10-9.&lt;/p&gt;</configure></property>
<property name="port:output" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Boolean output that is false as long as there is data to compare against the input; the value becomes true on the first firing after such data has been exhausted.</configure></property>
<property name="port:input" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>A multiport that accepts tokens of any type.</configure></property>
<property name="prop:tolerance" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>A double token specifying how closely the input must match the value from the correctValues array. The default is 10-9.</configure></property>
<property name="prop:correctValues" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>An array specifying what the input should be. If more than one input channel exists, then each element of the array must itself be an array, with length matching the number of channels. The default is a one-by-one array containing a Boolean true.</configure></property>
<property name="prop:trainingMode" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Select the trainingMode parameter to collect the input values and place them in the correctValues array. The trainingMode parameter is a shared parameter, meaning that changing it for any one instance of the actor in the model will change all instances.</configure></property>
</property>        <property name="entityId" class="org.kepler.moml.NamedObjId" value="urn:lsid:kepler-project.org/ns/:62508:10860:2">
        </property>
        <property name="class" class="ptolemy.kernel.util.StringAttribute" value="ptolemy.actor.lib.Test">
            <property name="id" class="ptolemy.kernel.util.StringAttribute" value="urn:lsid:kepler-project.org:class:985:1">
            </property>
        </property>
        <property name="semanticType00" class="org.kepler.sms.SemanticType" value="urn:lsid:localhost:onto:1:1#UnitTestControlActor">
        </property>
        <property name="semanticType11" class="org.kepler.sms.SemanticType" value="urn:lsid:localhost:onto:2:1#UnitTestControl">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[475.0, 320.0]">
        </property>
        <property name="derivedFrom" class="org.kepler.moml.NamedObjIdReferralList" value="urn:lsid:kepler-project.org:actor:116:1">
        </property>
    </entity>
    <entity name="DateSequence3" class="org.kepler.date.DateSequence">
        <property name="step" class="ptolemy.actor.parameters.PortParameter" value="2">
        </property>
        <property name="stepUnits" class="ptolemy.data.expr.StringParameter" value="Month">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[310.0, 440.0]">
        </property>
    </entity>
    <entity name="Test3" class="ptolemy.actor.lib.Test">
        <property name="correctValues" class="ptolemy.data.expr.Parameter" value="{{{date(&quot;Sat Jan 01 00:00:00.000000000 -0800 2000&quot;), date(&quot;Wed Mar 01 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon May 01 00:00:00.000000000 -0700 2000&quot;), date(&quot;Sat Jul 01 00:00:00.000000000 -0700 2000&quot;), date(&quot;Fri Sep 01 00:00:00.000000000 -0700 2000&quot;), date(&quot;Wed Nov 01 00:00:00.000000000 -0800 2000&quot;), date(&quot;Mon Jan 01 00:00:00.000000000 -0800 2001&quot;)}}}">
        </property>
        <property name="tolerance" class="ptolemy.data.expr.Parameter" value="1.0E-9">
        </property>
        <property name="requireAllCorrectValues" class="ptolemy.actor.parameters.SharedParameter" value="true">
        </property>
        <property name="trainingMode" class="ptolemy.actor.parameters.SharedParameter" value="false">
        </property>
<property name="KeplerDocumentation" class="ptolemy.vergil.basic.KeplerDocumentationAttribute">
<property name="description" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="author" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Edward A. Lee, Christopher Hylands, Jim Armstrong</configure></property>
<property name="version" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>null</configure></property>
<property name="userLevelDocumentation" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>&lt;p&gt;The Test actor reads an input value of any type and compares it to a corresponding value in a specified array of values. If the two values match, the actor fires successfully. If the two values do not match, the actor generates an error. The actor outputs a Boolean token: false if the actor's iteration count is less than or equal to the length of the comparison array; true if the iteration count is greater than the length of the array. The Boolean output can be fed to a Stop actor to stop the workflow upon successfully matching test data.&lt;/p&gt;&#10;&#10;&lt;p&gt;Unlike the NonstrictTest actor, the Test actor supports a multiport input. The actor also differs from NonstrictTest in that it requires that all inputs be present. &lt;/p&gt;&#10;&#10;&lt;p&gt;The comparison value is specified with the correctValues parameter. The parameter accepts an array of values, the type of which must match the type of the input (the default array is {true}). The actor cycles through the array values, comparing each consecutive input to the next token in the correctValues array. After each of the values in the correctValues parameter has been matched, any subsequent iteration always succeeds. This behavior allows the actor to be used as a &quot;power-up&quot; test for a model; the actor will check the first few iterations against some known results. &lt;/p&gt;&#10;&#10;&lt;p&gt;The input is a multiport. If more than one input channel exists, then each element of correctValues must itself be an array, with length matching the number of channels. &lt;/p&gt;&#10;&#10;&lt;p&gt;Suppose for example that the input consists of one channel, and the first three inputs should be 1, 2, and 3. Then set correctValues to &#10;&#10; {1, 2, 3}&lt;/p&gt;&#10;&#10;&lt;p&gt;Suppose instead that the input consists of two channels, and the correct values in the first iteration are 1 on the first channel and 2 on the second. Then on the second iteration, the correct values are 3 on the first channel and 4 on the second. Then set correctValues to &#10;&#10; {{1, 2}, {3, 4}}&#10;&#10;Note: With this setting, no tests are performed after the first two iterations of this actor. &lt;/p&gt;&#10;&#10;&lt;p&gt;The input values are checked when the actor fires. If an input value is missing or differs from what it should be, then the actor generates an error. To check the input value after the actor fires, then use the NonstrictTest actor. &lt;/p&gt;&#10;&#10;&lt;p&gt;If the input is a double or complex token, then the comparison &quot;passes&quot; if the value is close to what it should be (i.e., within the specified tolerance). Tolerance is specified with the tolerance parameter, and defaults to 10-9.&lt;/p&gt;</configure></property>
<property name="port:input" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>A multiport that accepts tokens of any type.</configure></property>
<property name="port:output" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Boolean output that is false as long as there is data to compare against the input; the value becomes true on the first firing after such data has been exhausted.</configure></property>
<property name="prop:correctValues" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>An array specifying what the input should be. If more than one input channel exists, then each element of the array must itself be an array, with length matching the number of channels. The default is a one-by-one array containing a Boolean true.</configure></property>
<property name="prop:tolerance" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>A double token specifying how closely the input must match the value from the correctValues array. The default is 10-9.</configure></property>
<property name="prop:trainingMode" class="ptolemy.kernel.util.ConfigurableAttribute"><configure>Select the trainingMode parameter to collect the input values and place them in the correctValues array. The trainingMode parameter is a shared parameter, meaning that changing it for any one instance of the actor in the model will change all instances.</configure></property>
</property>        <property name="entityId" class="org.kepler.moml.NamedObjId" value="urn:lsid:kepler-project.org/ns/:62508:10860:4">
        </property>
        <property name="class" class="ptolemy.kernel.util.StringAttribute" value="ptolemy.actor.lib.Test">
            <property name="id" class="ptolemy.kernel.util.StringAttribute" value="urn:lsid:kepler-project.org:class:985:1">
            </property>
        </property>
        <property name="semanticType00" class="org.kepler.sms.SemanticType" value="urn:lsid:localhost:onto:1:1#UnitTestControlActor">
        </property>
        <property name="semanticType11" class="org.kepler.sms.SemanticType" value="urn:lsid:localhost:onto:2:1#UnitTestControl">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[475.0, 440.0]">
        </property>
        <property name="derivedFrom" class="org.kepler.moml.NamedObjIdReferralList" value="urn:lsid:kepler-project.org:actor:116:1">
        </property>
    </entity>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="1">
        </property>
    </relation>
    <relation name="relation2" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="1">
        </property>
    </relation>
    <relation name="relation6" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[265.0, 210.0]">
        </vertex>
    </relation>
    <relation name="relation3" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[250.0, 280.0]">
        </vertex>
    </relation>
    <relation name="relation4" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation5" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation7" class="ptolemy.actor.TypedIORelation">
    </relation>
    <link port="CreateDate.output" relation="relation6"/>
    <link port="CreateDate.input" relation="relation2"/>
    <link port="CreateDate2.output" relation="relation3"/>
    <link port="CreateDate2.input" relation="relation"/>
    <link port="String Constant.output" relation="relation2"/>
    <link port="String Constant2.output" relation="relation"/>
    <link port="DateSequence.start" relation="relation6"/>
    <link port="DateSequence.stop" relation="relation3"/>
    <link port="DateSequence.output" relation="relation4"/>
    <link port="DateSequence2.start" relation="relation6"/>
    <link port="DateSequence2.stop" relation="relation3"/>
    <link port="DateSequence2.output" relation="relation5"/>
    <link port="Test.input" relation="relation4"/>
    <link port="Test2.input" relation="relation5"/>
    <link port="DateSequence3.start" relation="relation6"/>
    <link port="DateSequence3.stop" relation="relation3"/>
    <link port="DateSequence3.output" relation="relation7"/>
    <link port="Test3.input" relation="relation7"/>
</entity>
